package server;// This file contains material supporting section 3.7 of the textbook:// "Object Oriented Software Engineering" and is issued under the open-source// license found at www.lloseng.com import java.io.*;import java.net.UnknownHostException;import java.util.Observable;import java.util.Observer;import common.ChatIF;import com.lloseng.ocsf.server.*;/** * This class overrides some of the methods in the abstract superclass in order to give more functionality to the server. *  * @author Dr Timothy C. Lethbridge * @author Dr Robert Lagani&egrave;re * @author Fran&ccedil;ois B&eacute;langer * @author Paul Holden * @version July 2000 */public class EchoServer implements Observer {	// Class variables *************************************************	private ChatIF servUI;	private static ObservableOriginatorServer server;		public static final String SERVER_STARTED = "Server listening for connections on port ";	public static final String SERVER_STOPPED = "Server has stopped listening for connections.";	public static final String SERVER_CLOSED = "Server has closed.";	public static final String PORT_CHANGED = "Le nouveau port est : ";	// Constructors ****************************************************	/**	 * Constructs an instance of the echo server.	 * 	 * @param port	 *            The port number to connect on.	 */	public EchoServer(int port, ChatIF servUI) {		server = new ObservableOriginatorServer(port);		server.addObserver(this);		this.servUI = servUI;		try {			servUI.display("Bienvenue sur le GCAM Chat Server @ " + java.net.InetAddress.getLocalHost().getHostAddress().toString());		} catch (UnknownHostException e) {			e.printStackTrace();		}	}	// Send message to all clients but the client passed in parameters	public void sendToAllClients(Object msg, ConnectionToClient client) {		Thread[] clientThreadList = server.getClientConnections();		for (int i = 0; i < clientThreadList.length; i++) {			try {				if (!clientThreadList[i].equals(client)) {					((ConnectionToClient) clientThreadList[i]).sendToClient(msg);				}			} catch (Exception ex) {				ex.printStackTrace();			}		}	}		public static int getPort() {		return server.getPort();	}		// Instance methods ************************************************	/**	 * This method handles any messages received from the client.	 * 	 * @param msg	 *            The message received from the client.	 * @param client	 *            The connection from which the message originated.	 */	public void handleMessageFromClient(Object msg, ConnectionToClient client) {		servUI.display("Message received: " + msg + " from " + client);		if (isCommande(msg.toString())) {			handleCommand(msg.toString(), client);		} else if (isMessage(msg.toString())) {			server.sendToAllClients(client.getInfo("name") + "> " + msg);		}	}	/**	 * This method overrides the one in the superclass. Called when the server starts listening for connections.	 */	protected void serverStarted() {		servUI.display(SERVER_STARTED + server.getPort());	}	/**	 * This method overrides the one in the superclass. Called when the server stops listening for connections.	 */	protected void serverStopped() {		servUI.display(SERVER_STOPPED);	}		protected void serverClosed() {		servUI.display(SERVER_CLOSED);	}		/*	 * HandleCommand (from clientUI)	 */	private void handleCommand(String s, ConnectionToClient client) {		s = s.substring(1);		if (s.equals("quit")) {			try {				client.close();			} catch (IOException e) {				e.printStackTrace();			}		} else if (s.equals("logoff")) { 			try {				client.close();			} catch (IOException e) {				e.printStackTrace();			}		} else if (s.startsWith("pseudo ")) {			s = s.substring(7);			server.sendToAllClients(client.getInfo("name") + " s'appelle maintenant " + s + ".");			servUI.display(client.getInfo("name") + " s'appelle maintenant " + s + ".");			client.setInfo("name", s);		} else if (s.startsWith("login ")) {			if (client.getInfo("name") == null) { // le client n'a pas encore de pseudo				s = s.substring(6);				client.setInfo("name", s);				servUI.display("Client authentifie en tant que " + s);			}		}		server.sendToAllClients("$" + server.getUserList()); //TODO userList deco propre		servUI.display("UserList has been updated.");	}	/*	 * handleCommand (from server UI)	 */	private void handleCommand(String s) {		s = s.substring(1);		if (s.equals("stop")) {			if (server.isListening()) {				server.sendToAllClients("Le serveur est ferme, mais vous pouvez continuer a chat :)");				server.stopListening();			} else {				servUI.display("Erreur : le serveur n'est pas demarre !");			}		} else if (s.startsWith("close")) {			server.sendToAllClients("Arret du serveur !");			try {				server.close(); // deconnecte les clients			} catch (IOException e) {				e.printStackTrace();			}			handleCommand("stop");		} else if (s.equals("quit")) {			handleCommand("close");			System.exit(1);		} else if (s.equals("start")) {			if (server.isListening()) {				servUI.display("Lancement impossible : le serveur est deja en ecoute !");			} else {				try {					server.listen();				} catch (IOException e) {					e.printStackTrace();				}			}		} else if (s.equals("getport")) {			servUI.display("Port d'ecoute : " + server.getPort());		} else if (s.startsWith("setport ")) {			if (server.isListening()) {				servUI.display("Changement du port impossible : le serveur est deja  en ecoute !");			} else {				s = s.substring(8);				try {					if (Integer.parseInt(s) < 1 || Integer.parseInt(s) > 65535) {						servUI.display("Erreur : le port doit etre compris entre 1 et 65535.");					} else {						server.setPort(Integer.parseInt(s));						servUI.display(PORT_CHANGED + getPort());					}				} catch (ArrayIndexOutOfBoundsException e) {					s = "5555";					server.setPort(Integer.parseInt(s));					servUI.display("Erreur : le port a ete reinitialise.");				} catch (NumberFormatException n) {					servUI.display("Erreur : le port doit etre compris entre 1 et 65535.");				}			}		} else if (s.startsWith("kick ")) { //TODO #kick			s.substring(5);			servUI.equals(s);		}	}	private boolean isCommande(String s) {		return s.startsWith("#");	}	private boolean isMessage(String s) {		return (!s.startsWith("#"));	}	protected void clientConnected(ConnectionToClient client) {		servUI.display(client.getInfo("name") + " vient de se connecter."); 		sendToAllClients(client.getInfo("name") + " vient de se connecter.", client);	}	synchronized protected void clientDisconnected(ConnectionToClient client) {		servUI.display(client.getInfo("name") + " vient de se deconnecter.");		server.sendToAllClients(client.getInfo("name") + " vient de se deconnecter.");			}	synchronized protected void clientException(ConnectionToClient client, String exception) {		servUI.display("Erreur du client " + client.getInfo("name") + " (" + exception.substring(21) + ")");	}		synchronized protected void listeningException(String exception) {		servUI.display("Erreur lors de l'ecoute (" + exception.substring(24) + ")");	}	public void handleMessageFromServerUI(String message) {		if (isCommande(message)) {			handleCommand(message);		} else {			server.sendToAllClients("Server MSG> " + message);		}	}		public void update(Observable arg0, Object arg1) {		if (arg1 instanceof OriginatorMessage) {			if (((OriginatorMessage)arg1).getMessage().equals("#OS:Client connected.")) {				clientConnected(((OriginatorMessage)arg1).getOriginator()); //servUI.display("Notify : Client connected");			} else if (((OriginatorMessage)arg1).getMessage().equals("#OS:Client disconnected.")) { 				clientDisconnected(((OriginatorMessage)arg1).getOriginator()); //servUI.display("Notify : Client disconnected");			} else if (((String)((OriginatorMessage)arg1).getMessage()).startsWith("#OS:Client exception.")) {				clientException(((OriginatorMessage)arg1).getOriginator(), ((String)((OriginatorMessage)arg1).getMessage())); //servUI.display("Notify : Client exception");			} else if (((String)((OriginatorMessage)arg1).getMessage()).startsWith("#OS:Listening exception.")) {				listeningException(((String)((OriginatorMessage)arg1).getMessage())); //servUI.display("Notify : Listening exception");			} else if (((OriginatorMessage)arg1).getMessage().equals("#OS:Server closed.")) {				serverClosed(); //servUI.display("Notify : Server closed");			} else if (((OriginatorMessage)arg1).getMessage().equals("#OS:Server started.")) {				serverStarted(); //servUI.display("Notify : Server started");			} else if (((OriginatorMessage)arg1).getMessage().equals("#OS:Server stopped.")) {				serverStopped(); //servUI.display("Notify : Server stopped");			} else {				handleMessageFromClient(((OriginatorMessage)arg1).getMessage(), ((OriginatorMessage)arg1).getOriginator());			}		} else if (arg1 instanceof Exception) {			((Exception) arg1).printStackTrace();		}	}	public static String getServerStarted() {		return SERVER_STARTED;	}	public static String getServerStopped() {		return SERVER_STOPPED;	}	public static String getServerClosed() {		return SERVER_CLOSED;	}	public static String getPortChanged() {		return PORT_CHANGED;	}}// End of EchoServer class